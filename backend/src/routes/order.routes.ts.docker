import { Router, Response } from 'express';
import { PrismaClient } from '@prisma/client';
import QRCode from 'qrcode';
import { v4 as uuidv4 } from 'uuid';
import ExcelJS from 'exceljs';
import { AuthRequest, authMiddleware, adminMiddleware, canteenMiddleware } from '../middleware/auth.middleware';
import { cutoffMiddleware } from '../middleware/cutoff.middleware';
import { blacklistMiddleware } from '../middleware/blacklist.middleware';
import { sseManager } from '../controllers/sse.controller';
import { getNow, getToday, getTomorrow, isPastCutoff } from '../services/time.service';
import { logOrder, getRequestContext } from '../services/audit.service';
import { ErrorMessages, formatErrorMessage } from '../utils/errorMessages';

const router = Router();
const prisma = new PrismaClient();

// Get user's orders
router.get('/my-orders', authMiddleware, async (req: AuthRequest, res: Response) => {
    try {
        const { status, startDate, endDate, page = '1', limit = '20' } = req.query;

        const where: any = { userId: req.user?.id };

        if (status) where.status = status;
        if (startDate || endDate) {
            where.orderDate = {};
            if (startDate) where.orderDate.gte = new Date(startDate as string);
            if (endDate) where.orderDate.lte = new Date(endDate as string);
        }

        const skip = (parseInt(page as string) - 1) * parseInt(limit as string);

        const [orders, total] = await Promise.all([
            prisma.order.findMany({
                where,
                include: { shift: true },
                orderBy: { orderDate: 'desc' },
                skip,
                take: parseInt(limit as string),
            }),
            prisma.order.count({ where }),
        ]);

        res.json({
            orders,
            pagination: {
                page: parseInt(page as string),
                limit: parseInt(limit as string),
                total,
                totalPages: Math.ceil(total / parseInt(limit as string)),
            },
        });
    } catch (error) {
        console.error('Get orders error:', error);
        res.status(500).json({ error: ErrorMessages.SERVER_ERROR });
    }
});

// Get order for specific date (defaults to today) for current user
router.get('/today', authMiddleware, async (req: AuthRequest, res: Response) => {
    try {
        let queryDate: Date;

        // Check if date parameter is provided
        if (req.query.date) {
            queryDate = new Date(req.query.date as string);
            if (isNaN(queryDate.getTime())) {
                return res.status(400).json({ error: ErrorMessages.INVALID_ORDER_DATE });
            }
            queryDate.setHours(0, 0, 0, 0);
        } else {
            queryDate = getToday();
        }

        const nextDay = new Date(queryDate);
        nextDay.setDate(nextDay.getDate() + 1);

        const order = await prisma.order.findFirst({
            where: {
                userId: req.user?.id,
                orderDate: {
                    gte: queryDate,
                    lt: nextDay,
                },
                status: { not: 'CANCELLED' },
            },
            include: { shift: true },
        });

        res.json({ order });
    } catch (error) {
        console.error('Get order error:', error);
        res.status(500).json({ error: ErrorMessages.SERVER_ERROR });
    }
});

// Create order (with blacklist validation, cutoff validated per selected date inside)
router.post('/', authMiddleware, blacklistMiddleware, async (req: AuthRequest, res: Response) => {
    const context = getRequestContext(req);

    try {
        const { shiftId, orderDate: orderDateParam } = req.body;
        const userId = req.user?.id;

        if (!userId || !shiftId) {
            return res.status(400).json({ error: ErrorMessages.MISSING_REQUIRED_FIELDS });
        }

        // Parse and validate orderDate
        let orderDate: Date;
        if (orderDateParam) {
            // Parse date string as local date (avoid UTC timezone shift)
            // "2025-12-08" should become Dec 8 at 00:00 LOCAL, not UTC
            const dateParts = orderDateParam.split('-');
            if (dateParts.length === 3) {
                const year = parseInt(dateParts[0]);
                const month = parseInt(dateParts[1]) - 1; // JS months are 0-indexed
                const day = parseInt(dateParts[2]);
                orderDate = new Date(year, month, day, 0, 0, 0, 0);
            } else {
                orderDate = new Date(orderDateParam);
            }
            // Validate it's a valid date
            if (isNaN(orderDate.getTime())) {
                return res.status(400).json({ error: ErrorMessages.INVALID_ORDER_DATE });
            }
        } else {
            orderDate = getToday();
        }

        // Normalize to start of day (redundant but safe)
        orderDate.setHours(0, 0, 0, 0);

        // Check if date is in the past
        const today = getToday();
        if (orderDate < today) {
            return res.status(400).json({ error: ErrorMessages.PAST_DATE });
        }

        // Get settings to check maxOrderDaysAhead
        const settings = await prisma.settings.findUnique({ where: { id: 'default' } });
        const maxOrderDaysAhead = settings?.maxOrderDaysAhead || 7;
        const cutoffHours = settings?.cutoffHours || 6;

        // Calculate max allowed date
        const maxDate = new Date(today);
        maxDate.setDate(maxDate.getDate() + maxOrderDaysAhead);

        if (orderDate > maxDate) {
            return res.status(400).json({
                error: formatErrorMessage('MAX_DAYS_EXCEEDED', { days: maxOrderDaysAhead }),
                maxOrderDaysAhead
            });
        }

        // Check if user already has an order for this date
        const nextDay = new Date(orderDate);
        nextDay.setDate(nextDay.getDate() + 1);

        const existingOrder = await prisma.order.findFirst({
            where: {
                userId,
                orderDate: { gte: orderDate, lt: nextDay },
                status: { not: 'CANCELLED' },
            },
        });

        if (existingOrder) {
            return res.status(400).json({ error: ErrorMessages.ORDER_ALREADY_EXISTS });
        }

        // Check if the order date is a holiday (fullday or for this specific shift)
        // Use date range to check for holidays on the same day (ignore time)
        const holidayDateStart = new Date(orderDate);
        holidayDateStart.setHours(0, 0, 0, 0);
        const holidayDateEnd = new Date(orderDate);
        holidayDateEnd.setHours(23, 59, 59, 999);

        const holiday = await prisma.holiday.findFirst({
            where: {
                date: {
                    gte: holidayDateStart,
                    lte: holidayDateEnd
                },
                isActive: true,
                OR: [
                    { shiftId: null }, // Fullday holiday
                    { shiftId: shiftId } // Holiday for this specific shift
                ]
            },
            include: {
                shift: true
            }
        });

        if (holiday) {
            const message = holiday.shiftId
                ? `Tidak dapat memesan untuk ${holiday.shift?.name}: ${holiday.name}`
                : `Tidak dapat memesan makanan pada tanggal ini: ${holiday.name}`;
            return res.status(400).json({
                error: message,
                isHoliday: true,
                holidayName: holiday.name,
                isShiftSpecific: !!holiday.shiftId
            });
        }

        // Get shift for cutoff validation
        const shift = await prisma.shift.findUnique({ where: { id: shiftId } });
        if (!shift) {
            return res.status(404).json({ error: ErrorMessages.SHIFT_NOT_FOUND });
        }
        if (!shift.isActive) {
            return res.status(400).json({ error: ErrorMessages.SHIFT_INACTIVE });
        }

        // Calculate cutoff time for the selected date
        const [hours, minutes] = shift.startTime.split(':').map(Number);
        const shiftStartDateTime = new Date(orderDate);
        shiftStartDateTime.setHours(hours, minutes, 0, 0);

        const cutoffDateTime = new Date(shiftStartDateTime.getTime() - (cutoffHours * 60 * 60 * 1000));
        const now = getNow();

        // Check if we're past the cutoff for this date's shift
        if (now >= cutoffDateTime) {
            return res.status(403).json({
                error: ErrorMessages.CUTOFF_PASSED,
                message: `Pemesanan untuk ${shift.name} pada ${orderDate.toLocaleDateString('id-ID')} harus dilakukan sebelum ${cutoffDateTime.toLocaleTimeString('id-ID', { hour: '2-digit', minute: '2-digit', hour12: false })}`,
                cutoffTime: cutoffDateTime.toISOString(),
                shiftStart: shiftStartDateTime.toISOString(),
                currentTime: now.toISOString(),
            });
        }

        // Generate unique QR code
        const qrCodeData = `ORDER-${uuidv4()}`;
        const qrCodeImage = await QRCode.toDataURL(qrCodeData, {
            width: 300,
            margin: 2,
            color: { dark: '#000000', light: '#ffffff' },
        });

        const order = await prisma.order.create({
            data: {
                userId,
                shiftId,
                orderDate,
                qrCode: qrCodeData,
            },
            include: {
                user: { select: { id: true, name: true, externalId: true, company: true, division: true, department: true } },
                shift: true,
            },
        });

        // Log order creation
        await logOrder('ORDER_CREATED', req.user || null, order, context);

        // Broadcast to all clients
        sseManager.broadcast('order:created', {
            order,
            timestamp: getNow().toISOString(),
        });

        res.status(201).json({
            ...order,
            qrCodeImage,
        });
    } catch (error) {
        console.error('Create order error:', error);
        res.status(500).json({ error: ErrorMessages.SERVER_ERROR });
    }
});

// Get QR code for an order
router.get('/:id/qrcode', authMiddleware, async (req: AuthRequest, res: Response) => {
    try {
        const order = await prisma.order.findUnique({
            where: { id: req.params.id },
        });

        if (!order) {
            return res.status(404).json({ error: ErrorMessages.ORDER_NOT_FOUND });
        }

        // Check if user owns this order or is admin/canteen
        if (order.userId !== req.user?.id && req.user?.role === 'USER') {
            return res.status(403).json({ error: ErrorMessages.FORBIDDEN });
        }

        const qrCodeImage = await QRCode.toDataURL(order.qrCode, {
            width: 300,
            margin: 2,
        });

        res.json({ qrCode: order.qrCode, qrCodeImage });
    } catch (error) {
        console.error('Get QR code error:', error);
        res.status(500).json({ error: ErrorMessages.SERVER_ERROR });
    }
});

// Check-in by QR code (Canteen/Admin)
router.post('/checkin/qr', authMiddleware, canteenMiddleware, async (req: AuthRequest, res: Response) => {
    const context = getRequestContext(req);

    try {
        const { qrCode } = req.body;

        if (!qrCode) {
            return res.status(400).json({ error: ErrorMessages.MISSING_REQUIRED_FIELDS });
        }

        const order = await prisma.order.findUnique({
            where: { qrCode },
            include: {
                user: { select: { id: true, name: true, externalId: true, company: true, division: true, department: true } },
                shift: true,
            },
        });

        if (!order) {
            return res.status(404).json({ error: ErrorMessages.ORDER_NOT_FOUND });
        }

        if (order.status === 'PICKED_UP') {
            return res.status(400).json({ error: 'Pesanan sudah di-check in sebelumnya', order });
        }

        if (order.status === 'CANCELLED') {
            return res.status(400).json({ error: 'Pesanan sudah dibatalkan' });
        }

        // Validate order date and shift time window
        const now = getNow();
        const orderDate = new Date(order.orderDate);
        orderDate.setHours(0, 0, 0, 0);

        const [startHour, startMinute] = order.shift.startTime.split(':').map(Number);
        const [endHour, endMinute] = order.shift.endTime.split(':').map(Number);

        // Build shift start/end based on order date
        const shiftStart = new Date(orderDate);
        shiftStart.setHours(startHour, startMinute, 0, 0);

        const shiftEnd = new Date(orderDate);
        shiftEnd.setHours(endHour, endMinute, 0, 0);

        // Handle overnight shifts (e.g., 23:00 - 05:00)
        if (shiftEnd <= shiftStart) {
            shiftEnd.setDate(shiftEnd.getDate() + 1);
        }

        // Allow checkin 30 mins before start until end
        const allowedStart = new Date(shiftStart.getTime() - 30 * 60000);

        if (now < allowedStart) {
            return res.status(400).json({
                error: 'Terlalu dini untuk check-in',
                message: `Check-in dimulai pada ${allowedStart.toLocaleTimeString('id-ID')}`
            });
        }

        if (now > shiftEnd) {
            return res.status(400).json({
                error: 'Waktu check-in sudah lewat',
                message: `Check-in berakhir pada ${shiftEnd.toLocaleTimeString('id-ID')}`
            });
        }

        const updatedOrder = await prisma.order.update({
            where: { id: order.id },
            data: {
                status: 'PICKED_UP',
                checkInTime: getNow(),
            },
            include: {
                user: { select: { id: true, name: true, externalId: true, company: true, division: true, department: true } },
                shift: true,
            },
        });

        // Log checkin
        await logOrder('ORDER_CHECKIN', req.user || null, updatedOrder, context, {
            oldValue: { status: order.status },
            metadata: { checkedInBy: req.user?.externalId, method: 'QR' },
        });

        // Broadcast check-in to all clients
        sseManager.broadcast('order:checkin', {
            order: updatedOrder,
            timestamp: getNow().toISOString(),
        });

        res.json({
            message: 'Check-in berhasil',
            order: updatedOrder,
            checkInTime: updatedOrder.checkInTime,
            checkInBy: req.user?.externalId || 'Admin'
        });
    } catch (error) {
        console.error('Check-in error:', error);
        res.status(500).json({ error: ErrorMessages.SERVER_ERROR });
    }
});

// Check-in by user ID or name (Canteen/Admin)
router.post('/checkin/manual', authMiddleware, canteenMiddleware, async (req: AuthRequest, res: Response) => {
    try {
        const { externalId, name } = req.body;

        if (!externalId && !name) {
            return res.status(400).json({ error: ErrorMessages.MISSING_REQUIRED_FIELDS });
        }

        // Find user
        const user = await prisma.user.findFirst({
            where: externalId
                ? { externalId }
                : { name: { contains: name, mode: 'insensitive' } },
        });

        if (!user) {
            return res.status(404).json({ error: ErrorMessages.USER_NOT_FOUND });
        }

        // Find today's order for this user
        const today = getToday();
        const tomorrow = getTomorrow();

        const order = await prisma.order.findFirst({
            where: {
                userId: user.id,
                orderDate: { gte: today, lt: tomorrow },
                status: 'ORDERED',
            },
            include: { shift: true },
        });

        if (!order) {
            return res.status(404).json({ error: 'Tidak ada pesanan aktif untuk pengguna ini hari ini' });
        }

        // Validate order date and shift time window
        const now = getNow();
        const orderDate = new Date(order.orderDate);
        orderDate.setHours(0, 0, 0, 0);

        const [startHour, startMinute] = order.shift.startTime.split(':').map(Number);
        const [endHour, endMinute] = order.shift.endTime.split(':').map(Number);

        // Build shift start/end based on order date
        const shiftStart = new Date(orderDate);
        shiftStart.setHours(startHour, startMinute, 0, 0);

        const shiftEnd = new Date(orderDate);
        shiftEnd.setHours(endHour, endMinute, 0, 0);

        // Handle overnight shifts (e.g., 23:00 - 05:00)
        if (shiftEnd <= shiftStart) {
            shiftEnd.setDate(shiftEnd.getDate() + 1);
        }

        const allowedStart = new Date(shiftStart.getTime() - 30 * 60000);

        if (now < allowedStart) {
            return res.status(400).json({
                error: 'Too early for check-in',
                message: `Check-in starts at ${allowedStart.toLocaleTimeString()}`
            });
        }

        if (now > shiftEnd) {
            return res.status(400).json({
                error: 'Check-in time has passed',
                message: `Check-in ended at ${shiftEnd.toLocaleTimeString()}`
            });
        }

        const updatedOrder = await prisma.order.update({
            where: { id: order.id },
            data: {
                status: 'PICKED_UP',
                checkInTime: getNow(),
            },
            include: {
                user: { select: { id: true, name: true, externalId: true, company: true, division: true, department: true } },
                shift: true,
            },
        });

        // Broadcast check-in to all clients

        // Cancel order
        router.post('/:id/cancel', authMiddleware, async (req: AuthRequest, res: Response) => {
            const context = getRequestContext(req);

            try {
                const order = await prisma.order.findUnique({
                    where: { id: req.params.id },
                    include: { shift: true },
                });

                if (!order) {
                    return res.status(404).json({ error: ErrorMessages.ORDER_NOT_FOUND });
                }

                if (order.userId !== req.user?.id && req.user?.role === 'USER') {
                    return res.status(403).json({ error: ErrorMessages.FORBIDDEN });
                }

                if (order.status !== 'ORDERED') {
                    return res.status(400).json({ error: ErrorMessages.CANNOT_CANCEL_PICKED_UP });
                }

                // Check cutoff time - can only cancel BEFORE cutoff
                const settings = await prisma.settings.findUnique({ where: { id: 'default' } });
                const cutoffHours = settings?.cutoffHours || 6;
                const cutoffInfo = isPastCutoff(order.shift.startTime, cutoffHours);

                if (cutoffInfo.isPast) {
                    return res.status(400).json({
                        error: ErrorMessages.CANNOT_CANCEL_PAST_CUTOFF,
                        canCancel: false
                    });
                }

                const updatedOrder = await prisma.order.update({
                    where: { id: order.id },
                    data: { status: 'CANCELLED' },
                    include: {
                        user: { select: { id: true, name: true, externalId: true } },
                        shift: true,
                    },
                });

                // Log order cancellation
                await logOrder('ORDER_CANCELLED', req.user || null, updatedOrder, context, {
                    oldValue: { status: order.status },
                });

                sseManager.broadcast('order:cancelled', {
                    order: updatedOrder,
                    timestamp: getNow().toISOString(),
                });

                res.json({ message: 'Order cancelled', order: updatedOrder });
            } catch (error) {
                console.error('Cancel order error:', error);
                res.status(500).json({ error: 'Failed to cancel order' });
            }
        });

        // Get all orders (Admin only)
        router.get('/', authMiddleware, adminMiddleware, async (req: AuthRequest, res: Response) => {
            try {
                const { status, shiftId, startDate, endDate, search, page = '1', limit = '50' } = req.query;

                const where: any = {};

                if (status) where.status = status;
                if (shiftId) where.shiftId = shiftId;
                if (startDate || endDate) {
                    where.orderDate = {};
                    if (startDate) where.orderDate.gte = new Date(startDate as string);
                    if (endDate) where.orderDate.lte = new Date(endDate as string);
                }
                if (search) {
                    where.user = {
                        OR: [
                            { name: { contains: search as string, mode: 'insensitive' } },
                            { externalId: { contains: search as string, mode: 'insensitive' } },
                        ],
                    };
                }

                const skip = (parseInt(page as string) - 1) * parseInt(limit as string);

                const [orders, total] = await Promise.all([
                    prisma.order.findMany({
                        where,
                        include: {
                            user: { select: { id: true, name: true, externalId: true, company: true, division: true, department: true } },
                            shift: true,
                        },
                        orderBy: { orderDate: 'desc' },
                        skip,
                        take: parseInt(limit as string),
                    }),
                    prisma.order.count({ where }),
                ]);

                res.json({
                    orders,
                    pagination: {
                        page: parseInt(page as string),
                        limit: parseInt(limit as string),
                        total,
                        totalPages: Math.ceil(total / parseInt(limit as string)),
                    },
                });
            } catch (error) {
                console.error('Get all orders error:', error);
                res.status(500).json({ error: 'Failed to get orders' });
            }
        });

        // Process no-shows (Admin only) - run at end of day
        router.post('/process-noshows', authMiddleware, adminMiddleware, async (req: AuthRequest, res: Response) => {
            try {
                const today = getToday();
                const tomorrow = getTomorrow();

                // Find all orders that weren't picked up
                const noShowOrders = await prisma.order.findMany({
                    where: {
                        orderDate: { gte: today, lt: tomorrow },
                        status: 'ORDERED',
                    },
                    include: { user: true },
                });

                const settings = await prisma.settings.findUnique({ where: { id: 'default' } });
                const strikeThreshold = settings?.blacklistStrikes || 3;
                const blacklistDuration = settings?.blacklistDuration || 7;

                const results = { processed: 0, blacklisted: [] as string[] };

                for (const order of noShowOrders) {
                    // Mark as no-show
                    await prisma.order.update({
                        where: { id: order.id },
                        data: { status: 'NO_SHOW' },
                    });

                    // Increment user's no-show count
                    const updatedUser = await prisma.user.update({
                        where: { id: order.userId },
                        data: { noShowCount: { increment: 1 } },
                    });

                    results.processed++;

                    // Check if user should be blacklisted
                    if (updatedUser.noShowCount >= strikeThreshold) {
                        // Check if already blacklisted
                        const existingBlacklist = await prisma.blacklist.findFirst({
                            where: { userId: order.userId, isActive: true },
                        });

                        if (!existingBlacklist) {
                            const endDate = getNow();
                            endDate.setDate(endDate.getDate() + blacklistDuration);

                            await prisma.blacklist.create({
                                data: {
                                    userId: order.userId,
                                    reason: `Accumulated ${updatedUser.noShowCount} no-shows`,
                                    endDate,
                                },
                            });

                            results.blacklisted.push(updatedUser.externalId);

                            // Broadcast blacklist event
                            sseManager.broadcast('user:blacklisted', {
                                userId: order.userId,
                                userName: updatedUser.name,
                                noShowCount: updatedUser.noShowCount,
                                timestamp: getNow().toISOString(),
                            });
                        }
                    }

                    // Broadcast no-show event
                    sseManager.broadcast('order:noshow', {
                        orderId: order.id,
                        userId: order.userId,
                        userName: order.user.name,
                        noShowCount: order.user.noShowCount + 1,
                        timestamp: getNow().toISOString(),
                    });
                }

                res.json({
                    message: `Processed ${results.processed} no-shows`,
                    results,
                });
            } catch (error) {
                console.error('Process no-shows error:', error);
                res.status(500).json({ error: 'Failed to process no-shows' });
            }
        });

        // Export transactions (Admin only)
        router.get('/export', authMiddleware, adminMiddleware, async (req: AuthRequest, res: Response) => {
            try {
                const { startDate, endDate, status } = req.query;

                const where: any = {};
                if (startDate || endDate) {
                    where.orderDate = {};
                    if (startDate) where.orderDate.gte = new Date(startDate as string);
                    if (endDate) where.orderDate.lte = new Date(endDate as string);
                }
                if (status) where.status = status;

                const orders = await prisma.order.findMany({
                    where,
                    include: {
                        user: true,
                        shift: true,
                    },
                    orderBy: { orderDate: 'desc' },
                });

                const workbook = new ExcelJS.Workbook();
                const worksheet = workbook.addWorksheet('Transactions');

                worksheet.columns = [
                    { header: 'User ID', key: 'externalId', width: 15 },
                    { header: 'Name', key: 'name', width: 30 },
                    { header: 'Company', key: 'company', width: 20 },
                    { header: 'Division', key: 'division', width: 20 },
                    { header: 'Department', key: 'department', width: 20 },
                    { header: 'Shift', key: 'shift', width: 15 },
                    { header: 'Order Date', key: 'orderDate', width: 15 },
                    { header: 'Order Time', key: 'orderTime', width: 15 },
                    { header: 'Status', key: 'status', width: 15 },
                    { header: 'Pickup Time', key: 'checkInTime', width: 20 },
                ];

                // Style header
                worksheet.getRow(1).font = { bold: true };
                worksheet.getRow(1).fill = {
                    type: 'pattern',
                    pattern: 'solid',
                    fgColor: { argb: 'FF4F81BD' },
                };

                orders.forEach((order) => {
                    worksheet.addRow({
                        externalId: order.user.externalId,
                        name: order.user.name,
                        company: order.user.company,
                        division: order.user.division,
                        department: order.user.department,
                        shift: order.shift.name,
                        orderDate: order.orderDate.toLocaleDateString(),
                        orderTime: order.orderTime.toLocaleTimeString(),
                        status: order.status,
                        checkInTime: order.checkInTime?.toLocaleString() || '',
                    });
                });

                const filename = `transactions_${getNow().toISOString().split('T')[0]}.xlsx`;

                res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
                res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);

                await workbook.xlsx.write(res);
                res.end();
            } catch (error) {
                console.error('Export error:', error);
                res.status(500).json({ error: 'Failed to export transactions' });
            }
        });

        // Get order statistics (Admin only) - Enhanced with company, department, and risk users
        router.get('/stats/today', authMiddleware, adminMiddleware, async (req: AuthRequest, res: Response) => {
            try {
                const today = getToday();
                const tomorrow = getTomorrow();

                // Get settings for blacklist threshold
                const settings = await prisma.settings.findUnique({ where: { id: 'default' } });
                const blacklistStrikes = settings?.blacklistStrikes || 3;

                const yesterday = new Date(today);
                yesterday.setDate(yesterday.getDate() - 1);

                const [total, pickedUp, pending, cancelled, noShow, byShift, shifts, todayHolidays, blacklistedCount, usersAtRisk, ordersWithDetails, todayNoShowOrders, yesterdayNoShowOrders] = await Promise.all([
                    prisma.order.count({
                        where: { orderDate: { gte: today, lt: tomorrow } },
                    }),
                    prisma.order.count({
                        where: { orderDate: { gte: today, lt: tomorrow }, status: 'PICKED_UP' },
                    }),
                    prisma.order.count({
                        where: { orderDate: { gte: today, lt: tomorrow }, status: 'ORDERED' },
                    }),
                    prisma.order.count({
                        where: { orderDate: { gte: today, lt: tomorrow }, status: 'CANCELLED' },
                    }),
                    prisma.order.count({
                        where: { orderDate: { gte: today, lt: tomorrow }, status: 'NO_SHOW' },
                    }),
                    prisma.order.groupBy({
                        by: ['shiftId'],
                        where: { orderDate: { gte: today, lt: tomorrow } },
                        _count: { id: true },
                    }),
                    prisma.shift.findMany({ where: { isActive: true } }),
                    prisma.holiday.findMany({
                        where: {
                            date: { gte: today, lt: tomorrow },
                            isActive: true,
                        },
                        include: { shift: true },
                    }),
                    prisma.blacklist.count({
                        where: { isActive: true, OR: [{ endDate: null }, { endDate: { gt: getNow() } }] },
                    }),
                    prisma.user.findMany({
                        where: {
                            noShowCount: { gte: blacklistStrikes - 1, lt: blacklistStrikes },
                            isActive: true,
                        },
                        select: { id: true, externalId: true, name: true, company: true, department: true, noShowCount: true },
                        take: 10,
                    }),
                    prisma.order.findMany({
                        where: { orderDate: { gte: today, lt: tomorrow } },
                        include: {
                            user: { select: { company: true, department: true } },
                            shift: { select: { name: true } }
                        },
                    }),
                    // Today's no-show orders with user details
                    prisma.order.findMany({
                        where: {
                            orderDate: { gte: today, lt: tomorrow },
                            status: 'NO_SHOW'
                        },
                        include: {
                            user: { select: { id: true, externalId: true, name: true, company: true, department: true, noShowCount: true } },
                            shift: { select: { name: true } }
                        },
                    }),
                    // Yesterday's no-show orders with user details
                    prisma.order.findMany({
                        where: {
                            orderDate: { gte: yesterday, lt: today },
                            status: 'NO_SHOW'
                        },
                        include: {
                            user: { select: { id: true, externalId: true, name: true, company: true, department: true, noShowCount: true } },
                            shift: { select: { name: true } }
                        },
                    }),
                ]);

                // Calculate stats by company (filter out empty/null values)
                const companyStats: Record<string, { total: number; pickedUp: number; pending: number }> = {};
                const departmentStats: Record<string, {
                    total: number;
                    pickedUp: number;
                    pending: number;
                    byShift: Record<string, { total: number; pickedUp: number; noShow: number }>;
                }> = {};
                const companyShiftStats: Record<string, Record<string, { total: number; pickedUp: number; noShow: number }>> = {};

                ordersWithDetails.forEach((order) => {
                    const company = order.user.company?.trim();
                    const dept = order.user.department?.trim();
                    const shiftName = order.shift?.name || 'Unknown';

                    // Only count if company has a value
                    if (company && company.length > 0) {
                        if (!companyStats[company]) {
                            companyStats[company] = { total: 0, pickedUp: 0, pending: 0 };
                        }
                        companyStats[company].total++;
                        if (order.status === 'PICKED_UP') companyStats[company].pickedUp++;
                        if (order.status === 'ORDERED') companyStats[company].pending++;

                        // Company-Shift breakdown
                        if (!companyShiftStats[company]) {
                            companyShiftStats[company] = {};
                        }
                        if (!companyShiftStats[company][shiftName]) {
                            companyShiftStats[company][shiftName] = { total: 0, pickedUp: 0, noShow: 0 };
                        }
                        companyShiftStats[company][shiftName].total++;
                        if (order.status === 'PICKED_UP') companyShiftStats[company][shiftName].pickedUp++;
                        if (order.status === 'NO_SHOW') companyShiftStats[company][shiftName].noShow++;
                    }

                    // Only count if department has a value
                    if (dept && dept.length > 0) {
                        if (!departmentStats[dept]) {
                            departmentStats[dept] = { total: 0, pickedUp: 0, pending: 0, byShift: {} };
                        }
                        departmentStats[dept].total++;
                        if (order.status === 'PICKED_UP') departmentStats[dept].pickedUp++;
                        if (order.status === 'ORDERED') departmentStats[dept].pending++;

                        // Department-Shift breakdown
                        if (!departmentStats[dept].byShift[shiftName]) {
                            departmentStats[dept].byShift[shiftName] = { total: 0, pickedUp: 0, noShow: 0 };
                        }
                        departmentStats[dept].byShift[shiftName].total++;
                        if (order.status === 'PICKED_UP') departmentStats[dept].byShift[shiftName].pickedUp++;
                        if (order.status === 'NO_SHOW') departmentStats[dept].byShift[shiftName].noShow++;
                    }
                });

                const shiftStats = byShift.map((s) => {
                    const shift = shifts.find((sh) => sh.id === s.shiftId);
                    return {
                        shiftId: s.shiftId,
                        shiftName: shift?.name,
                        startTime: shift?.startTime,
                        endTime: shift?.endTime,
                        count: s._count.id,
                    };
                });

                // Sort company and department stats by total orders
                const byCompany = Object.entries(companyStats)
                    .map(([name, stats]) => ({ name, ...stats }))
                    .sort((a, b) => b.total - a.total)
                    .slice(0, 10);

                const byDepartment = Object.entries(departmentStats)
                    .map(([name, stats]) => ({
                        name,
                        total: stats.total,
                        pickedUp: stats.pickedUp,
                        pending: stats.pending,
                        byShift: Object.entries(stats.byShift).map(([shiftName, shiftData]) => ({
                            shiftName,
                            ...shiftData
                        }))
                    }))
                    .sort((a, b) => b.total - a.total)
                    .slice(0, 10);

                // Company-Shift recap for detailed view
                const companyShiftRecap = Object.entries(companyShiftStats)
                    .map(([companyName, shifts]) => ({
                        companyName,
                        shifts: Object.entries(shifts).map(([shiftName, data]) => ({
                            shiftName,
                            ...data
                        }))
                    }))
                    .sort((a, b) => {
                        const aTotal = a.shifts.reduce((sum, s) => sum + s.total, 0);
                        const bTotal = b.shifts.reduce((sum, s) => sum + s.total, 0);
                        return bTotal - aTotal;
                    });

                // Format no-show users from today and yesterday
                const todayNoShowUsers = todayNoShowOrders.map(order => ({
                    userId: order.user.id,
                    externalId: order.user.externalId,
                    name: order.user.name,
                    company: order.user.company,
                    department: order.user.department,
                    shiftName: order.shift.name,
                    noShowCount: order.user.noShowCount,
                    date: 'Hari Ini'
                }));

                const yesterdayNoShowUsers = yesterdayNoShowOrders.map(order => ({
                    userId: order.user.id,
                    externalId: order.user.externalId,
                    name: order.user.name,
                    company: order.user.company,
                    department: order.user.department,
                    shiftName: order.shift.name,
                    noShowCount: order.user.noShowCount,
                    date: 'Kemarin'
                }));

                // Combine and deduplicate by userId (show latest)
                const allNoShowUsers = [...todayNoShowUsers, ...yesterdayNoShowUsers];
                const uniqueNoShowUsers = Array.from(
                    new Map(allNoShowUsers.map(user => [user.userId, user])).values()
                );

                // Calculate pickup rate
                const pickupRate = total > 0 ? Math.round((pickedUp / total) * 100) : 0;

                res.json({
                    date: today.toISOString().split('T')[0],
                    total,
                    pickedUp,
                    pending,
                    cancelled,
                    noShow,
                    pickupRate,
                    byShift: shiftStats,
                    byCompany,
                    byDepartment,
                    companyShiftRecap,
                    noShowUsers: {
                        today: todayNoShowUsers,
                        yesterday: yesterdayNoShowUsers,
                        combined: uniqueNoShowUsers
                    },
                    holidays: todayHolidays.map((h) => ({
                        id: h.id,
                        name: h.name,
                        shiftName: h.shift?.name || 'Semua Shift',
                    })),
                    blacklistedCount,
                    usersAtRisk,
                    blacklistStrikes,
                });
            } catch (error) {
                console.error('Get stats error:', error);
                res.status(500).json({ error: 'Failed to get statistics' });
            }
        });

        // Process no-shows manually (Admin only)
        router.post('/process-no-shows', authMiddleware, adminMiddleware, async (req: AuthRequest, res: Response) => {
            try {
                const { processNoShows, getNoShowStats } = await import('../services/noshow.service');

                const result = await processNoShows();
                const stats = await getNoShowStats();

                res.json({
                    message: 'No-show processing completed',
                    result,
                    stats,
                });
            } catch (error) {
                console.error('Process no-shows error:', error);
                res.status(500).json({ error: 'Failed to process no-shows' });
            }
        });

        // Get no-show statistics (Admin only)
        router.get('/no-show-stats', authMiddleware, adminMiddleware, async (req: AuthRequest, res: Response) => {
            try {
                const { getNoShowStats } = await import('../services/noshow.service');
                const stats = await getNoShowStats();
                res.json(stats);
            } catch (error) {
                console.error('Get no-show stats error:', error);
                res.status(500).json({ error: 'Failed to get no-show statistics' });
            }
        });

        export default router;

